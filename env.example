# OpenRouter API Configuration (required for API-based embeddings)
# OPENROUTER_API_KEY is preferred; OPENAI_API_KEY is used as fallback
OPENROUTER_API_KEY=your_openrouter_api_key_here
OPENAI_API_KEY=your_openrouter_api_key_here
OPENAI_BASE_URL=https://openrouter.ai/api/v1

# GHCR Authentication (required for pushing graph artifacts)
# Graph is public, so pulling doesn't require auth
# Create a PAT at https://github.com/settings/tokens with write:packages scope
GHCR_TOKEN=ghp_your_token_here

# Neo4j Configuration
# Named graph profiles allow switching between instances at runtime.
# IMAS_CODEX_GRAPH selects the active profile (iter, tcv, jt60sa, etc.)
# Each profile maps to convention-based ports (iter=7687, tcv=7688, etc.)
# Priority: IMAS_CODEX_GRAPH env → pyproject.toml default → "iter"
IMAS_CODEX_GRAPH=iter

# Env var overrides (escape hatches, applied over any profile)
NEO4J_URI=bolt://localhost:7687
NEO4J_USERNAME=neo4j
NEO4J_PASSWORD=imas-codex

# Tunnel port overrides (only needed for dual-instance case)
# When accessing a remote graph AND a local graph simultaneously,
# the tunnel must bind a different local port to avoid conflict.
# Format: IMAS_CODEX_TUNNEL_BOLT_{HOST}=PORT (host upper-cased, hyphens → _)
# Then set up tunnel: ssh -f -N -L {PORT}:localhost:{graph_bolt_port} {host}
# Example: Run local iter-dev on 7687 + tunneled iter on 17687:
# IMAS_CODEX_TUNNEL_BOLT_ITER=17687
# Then: ssh -f -N -L 17687:localhost:7687 iter

# Private config sync via GitHub Gist
# Set this to auto-sync private facility YAML files via commit hooks
# IMAS_PRIVATE_GIST_ID=your_gist_id_here

# Local host detection
# Comma-separated SSH aliases that should be treated as local (no SSH).
# Required on sites where the SSH alias resolves to VIP/load-balancer
# addresses that differ from the login node's own network interfaces.
# Example: on ITER login node, 'iter' resolves to VIP IPs, not local.
# IMAS_CODEX_LOCAL_HOSTS=iter
